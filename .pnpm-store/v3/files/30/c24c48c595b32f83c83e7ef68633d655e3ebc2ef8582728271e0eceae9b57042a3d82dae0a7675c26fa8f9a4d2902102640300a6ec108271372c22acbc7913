"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getFixLocation = exports.fixErrorLocation = exports.fixLocation = exports.convertToken = exports.convertNode = void 0;
const traverse_1 = require("./traverse");
const errors_1 = require("./errors");
const token_store_1 = require("./token-store");
const require_utils_1 = require("./require-utils");
const lineBreakPattern = /\r\n|[\n\r\u2028\u2029]/u;
const octalNumericLiteralPattern = /^0[Oo]/u;
const legacyOctalNumericLiteralPattern = /^0\d/u;
const binaryNumericLiteralPattern = /^0[Bb]/u;
let cacheCodePointEscapeMatcher;
function getCodePointEscapeMatcher() {
    if (!cacheCodePointEscapeMatcher) {
        const utils = (0, require_utils_1.requireFromCwd)("eslint-utils") ||
            (0, require_utils_1.requireFromLinter)("eslint-utils") ||
            require("eslint-utils");
        cacheCodePointEscapeMatcher = new utils.PatternMatcher(/\\u\{[\dA-Fa-f]+\}/gu);
    }
    return cacheCodePointEscapeMatcher;
}
function convertNode(node, tokens, ctx) {
    if (node.type === "Program") {
        return convertProgramNode(node, tokens, ctx);
    }
    if (node.type === "ObjectExpression") {
        return convertObjectExpressionNode(node, tokens, ctx);
    }
    if (node.type === "ArrayExpression") {
        return convertArrayExpressionNode(node, tokens, ctx);
    }
    if (node.type === "Literal") {
        return convertLiteralNode(node, tokens, ctx);
    }
    if (node.type === "UnaryExpression") {
        return convertUnaryExpressionNode(node, tokens, ctx);
    }
    if (node.type === "Identifier") {
        return convertIdentifierNode(node, tokens, ctx);
    }
    if (node.type === "TemplateLiteral") {
        return convertTemplateLiteralNode(node, tokens, ctx);
    }
    return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
}
exports.convertNode = convertNode;
function convertToken(token) {
    if (token.type === "Punctuator") {
        if (token.value === "(" || token.value === ")") {
            return (0, errors_1.throwUnexpectedTokenError)(token.value, token);
        }
    }
    return Object.assign({ type: token.type, value: token.value }, getFixLocation(token));
}
exports.convertToken = convertToken;
function convertProgramNode(node, tokens, ctx) {
    if (node.type !== "Program") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    const bodyNode = node.body[0];
    if (bodyNode.type !== "ExpressionStatement") {
        return (0, errors_1.throwUnexpectedNodeError)(bodyNode, tokens);
    }
    const expression = bodyNode.expression;
    if (expression.type === "Identifier") {
        if (!isStaticValueIdentifier(expression, ctx)) {
            return (0, errors_1.throwUnexpectedNodeError)(expression, tokens);
        }
    }
    const body = Object.assign(Object.assign({ type: "JSONExpressionStatement", expression: convertNode(expression, tokens, ctx) }, getFixLocation(bodyNode)), { parent: null });
    const nn = Object.assign(Object.assign({ type: "Program", body: [body], comments: [], tokens: [] }, getFixLocation(node)), { parent: null });
    return nn;
}
function convertObjectExpressionNode(node, tokens, ctx) {
    if (node.type !== "ObjectExpression") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    if (!ctx.trailingCommas) {
        const token = tokens.getTokenBefore(tokens.getLastToken(node));
        if (token && (0, token_store_1.isComma)(token)) {
            return (0, errors_1.throwUnexpectedTokenError)(",", token);
        }
    }
    const nn = Object.assign(Object.assign({ type: "JSONObjectExpression", properties: node.properties.map((p) => convertPropertyNode(p, tokens, ctx)) }, getFixLocation(node)), { parent: null });
    checkUnexpectedKeys(node, tokens, nn);
    return nn;
}
function convertPropertyNode(node, tokens, ctx) {
    if (node.type !== "Property") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    if (node.computed) {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    if (node.method) {
        return (0, errors_1.throwUnexpectedNodeError)(node.value, tokens);
    }
    if (node.shorthand) {
        return (0, errors_1.throwExpectedTokenError)(":", node);
    }
    if (node.kind !== "init") {
        return (0, errors_1.throwExpectedTokenError)(":", tokens.getFirstToken(node));
    }
    if (node.key.type === "Literal") {
        const keyValueType = typeof node.key.value;
        if (keyValueType === "number") {
            if (!ctx.numberProperties) {
                return (0, errors_1.throwUnexpectedNodeError)(node.key, tokens);
            }
        }
        else if (keyValueType !== "string") {
            return (0, errors_1.throwUnexpectedNodeError)(node.key, tokens);
        }
    }
    else if (node.key.type === "Identifier") {
        if (!ctx.unquoteProperties) {
            return (0, errors_1.throwUnexpectedNodeError)(node.key, tokens);
        }
    }
    else {
        return (0, errors_1.throwUnexpectedNodeError)(node.key, tokens);
    }
    if (node.value.type === "Identifier") {
        if (!isStaticValueIdentifier(node.value, ctx)) {
            return (0, errors_1.throwUnexpectedNodeError)(node.value, tokens);
        }
    }
    const nn = Object.assign(Object.assign({ type: "JSONProperty", key: convertNode(node.key, tokens, ctx), value: convertNode(node.value, tokens, ctx), kind: node.kind, computed: node.computed, method: node.method, shorthand: node.shorthand }, getFixLocation(node)), { parent: null });
    checkUnexpectedKeys(node, tokens, nn);
    return nn;
}
function convertArrayExpressionNode(node, tokens, ctx) {
    if (node.type !== "ArrayExpression") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    if (!ctx.trailingCommas) {
        const token = tokens.getTokenBefore(tokens.getLastToken(node));
        if (token && (0, token_store_1.isComma)(token)) {
            return (0, errors_1.throwUnexpectedTokenError)(",", token);
        }
    }
    const elements = node.elements.map((child, index) => {
        if (!child) {
            if (ctx.sparseArrays) {
                return null;
            }
            const beforeIndex = index - 1;
            const before = beforeIndex >= 0
                ? tokens.getLastToken(node.elements[beforeIndex])
                : tokens.getFirstToken(node);
            return (0, errors_1.throwUnexpectedTokenError)(",", tokens.getTokenAfter(before, token_store_1.isComma));
        }
        if (child.type === "Identifier") {
            if (!isStaticValueIdentifier(child, ctx)) {
                return (0, errors_1.throwUnexpectedNodeError)(child, tokens);
            }
        }
        return convertNode(child, tokens, ctx);
    });
    const nn = Object.assign(Object.assign({ type: "JSONArrayExpression", elements }, getFixLocation(node)), { parent: null });
    checkUnexpectedKeys(node, tokens, nn);
    return nn;
}
function isRegExpLiteral(node) {
    return Boolean(node.regex);
}
function convertLiteralNode(node, tokens, ctx) {
    if (node.type !== "Literal") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    let nn;
    if (isRegExpLiteral(node)) {
        if (!ctx.regExpLiterals) {
            return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
        }
        nn = Object.assign({ type: "JSONLiteral", value: node.value, raw: node.raw, regex: node.regex }, getFixLocation(node));
    }
    else if (node.bigint) {
        if (!ctx.bigintLiterals) {
            return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
        }
        nn = Object.assign({ type: "JSONLiteral", value: node.value, raw: node.raw, bigint: node.bigint }, getFixLocation(node));
    }
    else {
        validateLiteral(node, ctx);
        const value = node.value;
        nn = Object.assign({ type: "JSONLiteral", value, raw: node.raw }, getFixLocation(node));
    }
    checkUnexpectedKeys(node, tokens, nn);
    return nn;
}
function validateLiteral(node, ctx) {
    const value = node.value;
    if ((!ctx.invalidJsonNumbers ||
        !ctx.leadingOrTrailingDecimalPoints ||
        !ctx.numericSeparators) &&
        typeof value === "number") {
        const text = node.raw;
        if (!ctx.leadingOrTrailingDecimalPoints) {
            if (text.startsWith(".")) {
                return (0, errors_1.throwUnexpectedTokenError)(".", node);
            }
            if (text.endsWith(".")) {
                return (0, errors_1.throwUnexpectedTokenError)(".", {
                    range: [node.range[1] - 1, node.range[1]],
                    loc: {
                        start: {
                            line: node.loc.end.line,
                            column: node.loc.end.column - 1,
                        },
                        end: node.loc.end,
                    },
                });
            }
        }
        if (!ctx.numericSeparators) {
            if (text.includes("_")) {
                const index = text.indexOf("_");
                return (0, errors_1.throwUnexpectedTokenError)("_", {
                    range: [node.range[0] + index, node.range[0] + index + 1],
                    loc: {
                        start: {
                            line: node.loc.start.line,
                            column: node.loc.start.column + index,
                        },
                        end: {
                            line: node.loc.start.line,
                            column: node.loc.start.column + index + 1,
                        },
                    },
                });
            }
        }
        if (!ctx.octalNumericLiterals) {
            if (octalNumericLiteralPattern.test(text)) {
                return (0, errors_1.throwUnexpectedError)("octal numeric literal", node);
            }
        }
        if (!ctx.legacyOctalNumericLiterals) {
            if (legacyOctalNumericLiteralPattern.test(text)) {
                return (0, errors_1.throwUnexpectedError)("legacy octal numeric literal", node);
            }
        }
        if (!ctx.binaryNumericLiterals) {
            if (binaryNumericLiteralPattern.test(text)) {
                return (0, errors_1.throwUnexpectedError)("binary numeric literal", node);
            }
        }
        if (!ctx.invalidJsonNumbers) {
            try {
                JSON.parse(text);
            }
            catch (_a) {
                return (0, errors_1.throwInvalidNumberError)(text, node);
            }
        }
    }
    if ((!ctx.multilineStrings ||
        !ctx.singleQuotes ||
        !ctx.unicodeCodepointEscapes) &&
        typeof value === "string") {
        if (!ctx.singleQuotes) {
            if (node.raw.startsWith("'")) {
                return (0, errors_1.throwUnexpectedError)("single quoted", node);
            }
        }
        if (!ctx.multilineStrings) {
            if (lineBreakPattern.test(node.raw)) {
                return (0, errors_1.throwUnexpectedError)("multiline string", node);
            }
        }
        if (!ctx.unicodeCodepointEscapes) {
            if (getCodePointEscapeMatcher().test(node.raw)) {
                return (0, errors_1.throwUnexpectedError)("unicode codepoint escape", node);
            }
        }
    }
    return undefined;
}
function convertUnaryExpressionNode(node, tokens, ctx) {
    if (node.type !== "UnaryExpression") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    const operator = node.operator;
    if (operator === "+") {
        if (!ctx.plusSigns) {
            return (0, errors_1.throwUnexpectedTokenError)("+", node);
        }
    }
    else if (operator !== "-") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    const argument = node.argument;
    if (argument.type === "Literal") {
        if (typeof argument.value !== "number") {
            return (0, errors_1.throwUnexpectedNodeError)(argument, tokens);
        }
    }
    else if (argument.type === "Identifier") {
        if (!isNumberIdentifier(argument, ctx)) {
            return (0, errors_1.throwUnexpectedNodeError)(argument, tokens);
        }
    }
    else {
        return (0, errors_1.throwUnexpectedNodeError)(argument, tokens);
    }
    if (!ctx.spacedSigns) {
        if (node.range[0] + 1 < argument.range[0]) {
            return (0, errors_1.throwUnexpectedSpaceError)(tokens.getFirstToken(node));
        }
    }
    const nn = Object.assign(Object.assign({ type: "JSONUnaryExpression", operator, prefix: node.prefix, argument: convertNode(argument, tokens, ctx) }, getFixLocation(node)), { parent: null });
    checkUnexpectedKeys(node, tokens, nn);
    return nn;
}
function convertIdentifierNode(node, tokens, ctx) {
    if (node.type !== "Identifier") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    if (!ctx.escapeSequenceInIdentifier) {
        if (node.name.length < node.range[1] - node.range[0]) {
            return (0, errors_1.throwUnexpectedError)("escape sequence", node);
        }
    }
    const nn = Object.assign({ type: "JSONIdentifier", name: node.name }, getFixLocation(node));
    checkUnexpectedKeys(node, tokens, nn);
    return nn;
}
function convertTemplateLiteralNode(node, tokens, ctx) {
    if (node.type !== "TemplateLiteral") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    if (!ctx.templateLiterals) {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    if (node.expressions.length) {
        const token = tokens.getFirstToken(node.quasis[0]);
        const loc = {
            loc: {
                start: {
                    line: token.loc.end.line,
                    column: token.loc.end.column - 2,
                },
                end: token.loc.end,
            },
            range: [token.range[1] - 2, token.range[1]],
        };
        return (0, errors_1.throwUnexpectedTokenError)("$", loc);
    }
    if (!ctx.unicodeCodepointEscapes) {
        if (getCodePointEscapeMatcher().test(node.quasis[0].value.raw)) {
            return (0, errors_1.throwUnexpectedError)("unicode codepoint escape", node);
        }
    }
    const quasis = [
        convertTemplateElementNode(node.quasis[0], tokens),
    ];
    const nn = Object.assign(Object.assign({ type: "JSONTemplateLiteral", quasis, expressions: [] }, getFixLocation(node)), { parent: null });
    checkUnexpectedKeys(node, tokens, nn);
    return nn;
}
function convertTemplateElementNode(node, tokens) {
    if (node.type !== "TemplateElement") {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    const { cooked, raw } = node.value;
    if (cooked == null) {
        return (0, errors_1.throwUnexpectedNodeError)(node, tokens);
    }
    const nn = Object.assign(Object.assign({ type: "JSONTemplateElement", tail: node.tail, value: { raw, cooked } }, getFixLocation(node)), { parent: null });
    checkUnexpectedKeys(node, tokens, nn);
    return nn;
}
function isStaticValueIdentifier(node, ctx) {
    if (isNumberIdentifier(node, ctx)) {
        return true;
    }
    return node.name === "undefined" && ctx.undefinedKeywords;
}
function isNumberIdentifier(node, ctx) {
    if (node.name === "Infinity" && ctx.infinities) {
        return true;
    }
    if (node.name === "NaN" && ctx.nans) {
        return true;
    }
    return false;
}
function checkUnexpectedKeys(node, tokens, jsonNode) {
    const keys = (0, traverse_1.getKeys)(node);
    for (const key of keys) {
        if (!(key in jsonNode)) {
            (0, errors_1.throwUnexpectedNodeError)((0, traverse_1.getNodes)(node, key).next().value, tokens);
        }
    }
}
function fixLocation(node) {
    const locs = getFixLocation(node);
    node.range = locs.range;
    node.loc = locs.loc;
}
exports.fixLocation = fixLocation;
function fixErrorLocation(error) {
    error.index = Math.max(error.index - 2, 0);
    if (error.lineNumber === 0) {
        error.column = Math.max(error.column - 2, 0);
    }
}
exports.fixErrorLocation = fixErrorLocation;
function getFixLocation(node) {
    const range = node.range;
    const loc = node.loc;
    return {
        range: [Math.max(range[0] - 2, 0), Math.max(range[1] - 2, 0)],
        loc: {
            start: {
                line: loc.start.line,
                column: loc.start.line === 1
                    ? Math.max(loc.start.column - 2, 0)
                    : loc.start.column,
            },
            end: {
                line: loc.end.line,
                column: loc.end.line === 1
                    ? Math.max(loc.end.column - 2, 0)
                    : loc.end.column,
            },
        },
    };
}
exports.getFixLocation = getFixLocation;
